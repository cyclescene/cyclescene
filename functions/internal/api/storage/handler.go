package storage

import (
	"encoding/json"
	"log/slog"
	"net/http"

	"github.com/go-chi/chi/v5"
)

type Handler struct {
	service *Service
}

func NewHandler(service *Service) *Handler {
	return &Handler{service: service}
}

func (h *Handler) RegisterRoutes(r chi.Router) {
	r.Route("/storage", func(r chi.Router) {
		r.Post("/upload-url", h.GenerateUploadURL)
	})
}

// GenerateUploadURL generates a signed URL for uploading files to the staging bucket
// Request: POST /v1/storage/upload-url
//
//	Body: {
//	  "file_name": "my-image.jpg",
//	  "file_type": "image/jpeg",
//	  "city_code": "pdx",
//	  "entity_type": "ride"
//	}
//
//	Response: {
//	  "success": true,
//	  "signed_url": "https://storage.googleapis.com/...",
//	  "object_name": "{uuid}.jpg",
//	  "image_uuid": "{uuid}",  // Generated by API
//	  "expires_at": "2024-10-18T18:00:00Z",
//	  "bucket_name": "project-user-media-staging"
//	}
func (h *Handler) GenerateUploadURL(w http.ResponseWriter, r *http.Request) {
	var req SignedURLRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		slog.Error("failed to decode request", "error", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		if err := json.NewEncoder(w).Encode(SignedURLResponse{
			Success: false,
			Error:   "invalid request body",
		}); err != nil {
			slog.Error("failed to encode error response", "error", err)
		}
		return
	}

	// Validate request
	if req.FileName == "" || req.FileType == "" {
		slog.Warn("missing required fields", "file_name", req.FileName, "file_type", req.FileType)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		if err := json.NewEncoder(w).Encode(SignedURLResponse{
			Success: false,
			Error:   "file_name and file_type are required",
		}); err != nil {
			slog.Error("failed to encode error response", "error", err)
		}
		return
	}

	// Validate file type (only allow image types)
	if !isAllowedMimeType(req.FileType) {
		slog.Warn("invalid file type", "file_type", req.FileType)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		if err := json.NewEncoder(w).Encode(SignedURLResponse{
			Success: false,
			Error:   "only image files (JPEG, PNG, WebP, GIF) are allowed",
		}); err != nil {
			slog.Error("failed to encode error response", "error", err)
		}
		return
	}

	slog.Info("generating signed upload URL", "file_name", req.FileName, "file_type", req.FileType)

	response, err := h.service.GenerateSignedURL(r.Context(), &req)
	if err != nil {
		slog.Error("failed to generate signed URL", "error", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(SignedURLResponse{
			Success: false,
			Error:   "failed to generate signed URL: " + err.Error(),
		})
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// isAllowedMimeType checks if the MIME type is allowed for uploads
func isAllowedMimeType(mimeType string) bool {
	allowedTypes := map[string]bool{
		"image/jpeg": true,
		"image/png":  true,
		"image/webp": true,
		"image/gif":  true,
	}
	return allowedTypes[mimeType]
}
